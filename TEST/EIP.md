1. 요구사항 확인  
- 프레임워크 : 소프트웨어의 특정 부분 설계 및 구현 시 재사용이 가능하도록 클래스 제공  
- 소프트웨어 프레임워크의 특징 : 모듈화(인터페이스에 의한 캡슐화), 재사용성(반복적으로 사용하는 컴포넌트를 정의할 수 있게 함), 확장성(다형성을 통해 프레임워크의 인터페이스를 넓게 사용), 제어의 역흐름(프레임워크 코드가 전체 애플리케이션의 처리 흐름을 제어 -> 제어가 반대로 흐르게 함)  
- 다형성 : 프로그래밍 언어의 요소들이 다양한 자료형에 속하는 것이 허가되는 성질(오버로딩, 오버라이딩)  
- Component : 특정 기능 수행을 위해 독립적 개발/보급되고 다른 부품과 조립되어 사용되는 S/W 단위  
- 4+1 VIEW : 유스케이스(아키텍처 설계 작업 주도), 논리, 프로세스, 배포, 구현 뷰  
- JDBC : JAVA 언어를 이용하여 DB에 접근하여 관리할 수 있는 인터페이스  
- ODBC : 응용프로그램에서 DB에 접근하여 데이터를 관리할 수 있는 표준 인터페이스  
- Middleware : 운영체제와 SW 사이에서 원만한 통신이 이루어질 수 있도록 중개/제어 역할을 하는 SW  
- RPC(Remote Procedure Call): 원격 프로시저를 마치 로컬 프로시저처럼 호출하는 방식의 미들웨어  
- MOM(Message Oriented Middleware) : 메시지 기반의 비동기형 메시지를 전달하는 방식의 미들웨어  
- TP-Monitor : 온라인 트랜잭션 업무에서 트랜잭션을 처리 및 감시하는 미들웨어  - ORB(Object Request Broker) : 코바(CORBA) 표준 스펙을 규현한 객체 지향 미들웨어  
- WAS(Web Application Server): 사용자의 동적인 콘텐츠를 처리하기 위해 사용되는 미들웨어  
- OLTP(OnLine Transaction Processing) : 네트워크에서 여러 이용자가 실시간으로 DB 작업 처리하는 방식  
- tpmC : 특정 서버 1분당 최대 처리 건수, 객관적인 하드웨어 성능 지표로 사용  
- 요구사항 개발 프로세스 : 도출 -> 분석 -> 명세 -> 확인  
- Prototyping : 새로운 요구사항 도출 수단/요구사항에 대해 개발자가 해석한 것을 확인하기 위한 수단  
- 하향식 선정방법 : 전문가 판단, 델파이 기법(전문가들의 경험적 지식을 통해 미래 예측)  
- 상향식 선정방법 : LOC, Man/Month, Putnam(개발 주기 단계별 요구 + 인원 분포, COCOMO(프로그램 규모))  
- UML : 개발자들의 의사소통을 원활히 해주는 객체지향 모델링 언어 - 다이어그램, 사물, 관계  
- UML 관계 : 연관 ―, 집합 ◇, 포함(영향을 끼침) ◆, 일반화 ㅡ|>, 의존(일시적) --→, 실체화(행위) --|>  
- 구조적 다이어그램 : 클래스, 객체, 컴포넌트, 배치, 복합체 구조, 패키지  
- 행위 다이어그램 : 유스케이스, 시퀀스(메시지 흐름), 커뮤니케이션, 상태, 활동, 상호작용 개요, 타이밍  

2. 데이터 입출력 구현  
- 데이터 모델링 : 개념적 -> 논리적 -> 물리적  
- 이상 현상 : 데이터의 중복성으로 인해 테이블을 조작할 때 발생하는 비합리적인 현상(삽입, 삭제, 갱신)  
- 반정규화 : 시스템의 성능 향상을 위해 정규화 원칙을 의도적으로 위배하는 행위  
- 정규화 : 관계형 DB 설계 시 중복을 최소화하여 데이터를 구조화하는 과정  
- 제 1정규화(테이블 내의 속성 값은 원자 값), 제 2정규화(부분 함수 종속성을 제거), 제 3정규화(이행 함수 종속성을 제거), BCNF(결정자 함수의 종속성을 제거), 제 4정규화(다중 값 종속을 제거), 제 5정규화(조인 종속성을 제거)  
- Index : 검색 연산의 최적화를 위해 키값과 포인터의 쌍으로 구성되는 데이터 구조  
- View : 사용자에게 허용된 정보만 보여주기 위해 하나 이상의 테이블로부터 유도된 논리적인 가상 테이블  
- Cluster : 데이터 접근 효율을 높이기 위해 동일한 성격의 데이터를 같은 데이터 블록에 저장하는 방법  
- Partitioning : 대용량 테이블을 작은 논리적인 단위인 파티션으로 나누는 것(해시,레인지,리스트,컴포지트)  
- PL/SQL(Procedural Language for SQL) : 표준 SQL을 기반으로 Oracle에서 개발한 데이터 조작 언어  
- APM(Application Performance Monitoring) : 안정적인 시스템 운영을 위한 성능 모니터링 도구  
- Optimizer : SQL을 가장 빠르고 효율적으로 수행할 수 있는 최적의 경로(=실행 계획) 생성  
- RBO(규칙 기반 옵티마이저-사전 등록 규칙에 따라), CBO(비용 기반 옵티마이저-모든 접근 경로를 고려)  

3. 통합 구현  
- 연계 시스템 구성 : 송신 시스템, 수신 시스템, 중계 서버  
- 직접 연계(DB Link, DB Connection, API, JDBC) vs 간접 연계(EAI, ESB/Web Service, Socket)  
- EAI : 기업에서 운영, 이기종 간 시스템 연계 솔루션(Point-to-Point, Hub&Spoke, Message Bus, Hybrid)  
- Adapter : 이기종 간을 연결하는 EAI의 핵심 장치  
- ESB : 기업에서 운영, 이기종 간 서비스를 통합 -> 하나의 시스템으로 관리 운영(SOA의 토대, BUS 이용)  
- SOA(Service-Oriented Architecture) : 느슨하게 결합된 서비스 기반 APP을 구현하기 위한 아키텍처 모델  
- SOAP : HTTP, HTTPS, SMTP 프로토콜을 사용하여 XML 기반의 메시지를 교환하는 프로토콜  
- WSDL(Web Service Description Language) : 웹 서비스에 대한 상세 정보를 기록한 파일  
- UDDI(Universal Description Discovery Integration) : WSDL을 등록하고 검색하기 위한 저장소  
- XML : HTML 문법이 호환되지 않는 문제와 SGML의 복잡함을 해결하기 위해 고안된 마크업 언어  
- JSON : 비동기 브라우저, 서버 통신을 위해 '속성-값'의 쌍으로 이루어진 개방형 표준 포맷  
- AJAX : JS를 이용한 비동기 통신으로 클라이언트와 서버 간 XML 데이터를 주고받는 기술  
- REST : URL을 통해 자원을 명시하고 HTTP 메서드를 통해 해당 자원을 조작할 수 있는 웹 아키텍처  

4. 서버 프로그램 구현  
- JVM : JAVA 기반 APP을 위해 시스템 메모리를 관리하고 실행 환경을 제공하는 가상 머신  
- JDK : JAVA 기반 APP을 개발하는 데 필요한 툴들을 모아놓은 소프트웨어 패키지(JVM 포함)  
- JUnit : jAVA용 단위 테스트 도구 *어노테이션 : 주석을 달아 특별한 의미를 부여하는 메타데이터  
- Module : 기능 단위로 분해 및 추상화되어 재사용 및 공유가 가능한 단위  
- 모듈화 : 모듈을 통해 소프트웨어의 성능을 향상시키고 디버깅, 수정, 통합을 용이하게 하는 설계 기법  
- 결합도 : 상호 의존의 정도(data-stamp-control-external-common-content)  
- 자료(데이터 넘겨 주기), 스탬프(자료구조), 제어(흐름), 외부(참조), 공통(여럿이 공유), 내용(직접 참조/수정)  
- 응집도 : functional - sequential - communication - procedural - temporal - logical - coincidental  
- 기능(단일), 순차(출력->입력), 통신/교환(동일한 입출력), 절차(순차 수행), 시간, 논리(유사한 성격), 우연 ->우논시절통순기  
- DTO(Data Transfer Object) : 프로세스 사이에서 데이터를 전송하는 객체  
- VO(Value Object) : 고정 클래스를 가지는 객체  
- DAO(Data Access Object) : 특정 타입의 DB 추상 인터페이스를 제공하는 객체  
- GoF(Gang of Four) 디자인 패턴 : 생성 패턴, 구조 패턴, 행위 패턴  
- 생성 패턴 : 추상 팩토리(의존적인 객체들의 조합), 빌더(복잡한 인스턴스 조립, 생성과 표기 분리), 팩토리 메소드(상위클래스-인터페이스 정의/하위클래스 - 인스턴스 생성), 프로토타입(일반적인 원형을 복제, 필요한 부분만 수정), 싱글톤(전역변수 사용 않고 한 클래스에 한 객체만)  
- 구조 패턴 : 어댑터(기존 클래스 재사용, 덧씌움), 브리지(구현부에서 추상층 분리), 컴포지트(트리 구조, 부분-전체 계층), 데코레이터(기능을 추가해 나감), 퍼싸드(거대한 코드에 접근할 수 있는 단순한 인터페이스 제공), 플라이웨이트(유사 객체들 메모리 사용량 최소화), 프록시(접근 힘든 객체에 대한 대역 제공)  
- 행위 패턴 : 커맨드(캡슐화 -> 재사용성 높은 클래스 설계), 옵저버(객체 상태 변화시 다른 객체들에게 연락), 템플릿 메소드(알고리즘 정의), 책임 연쇄(처리 못하면 다음 객체로), 중재자(객체간 의존성 줄여 결합도 감소), 전략(동일 알고리즘들 캡슐화 -> 상호 교환), 메멘토(Ctrl+Z)  
- 팬 인(어떤 모듈을 제어하는 수), 팬 아웃(어떤 모듈이 제어하는 수)  
- 화이트박스 테스트(내부 구조와 동작 검사), 블랙박스 테스트(기능 작동 여부 확인)  
- 배치 프로그램 : 유저와 상호작용 없이 일련의 작업을 묶어 정기적으로 반복 수행하는 일괄 처리 방법  
- 스프링 배치 : 스프링 프레임워크, 대용량 처리를 제공하는 스케줄러 (ㄴ정기/이벤트/온디맨드 배치)  
- 쿼츠 스케줄러 : 스프링 프레임워크에 플러그인, job/trigger 분리하여 유연성 제공하는 배치 스케줄러  
- Cron 표현식 : 스케줄러를 실행시키기 위해 작업이 실행되는 주기를 설정하는 표현식  

5. 인터페이스 구현  
- 인터페이스 설계서 : 이기종 시스템 및 컴포넌트 간 데이터 교환 및 처리를 위해 각 시스템이 교환되는 데이터, 업무, 송수신 주체 등이 정의된 문서  
- 스니핑 : 직접 공격하지 않고 네트워크 중간에서 남의 패킷 정보를 몰래 도청하는 공격 기법  
- 인터페이스 보안 취약점 : 입력데이터 검증/표현(검증 누락, 잘못된 형식), 보안기능(인증/암호화/권한 관리 등 기능을 부적절하게 구현), 시간 및 상태(부적절 관리), 에러 처리(부적절 예외처리), 코드 오류(널 포인터 역참조, 부적절 자원 해제), 캡슐화(잘못된 세션, 디버그 코드, 시스템 데이터 정보 노출), API 오용  
- DB 암호화 기법 : API 방식, Plug-In 방식, Hybrid 방식  
- IPSec : 무결성과 인증을 보장하는 인증 헤더와 기밀성을 보장하는 암호화를 이용한 IP 보안 프로토콜  
- SSL/TLS : APP과 TCP/IP 계층 사이에서 데이터를 암호화하고 기밀성을 보장하는 공개키 기반 보안 프로토콜  
- 인터페이스 구현 검증을 위한 테스트 프레임워크 : xUnit(다양한 언어), STAF(서비스 호출/컴포넌트 재사용/다양한 환경), FitNesse(웹 기반), NTAF(FitNesse+STAF,NHN), Selenium(다양한 브라우저), Watir(Ruby)  
- 스카우터 : APP 모니터링 및 DB 모니터링, 인터페이스 감시 기능 제공하는 인터페이스 도구  

6. 화면 설계  
- UI : 유저와 시스템 사이에서 의사소통을 할 수 있도록 고안된 물리적 가상의 매개체(CLI, GUI, NUI)  
- UI 설계 원칙 : 직관성(누구나 쉽게 이해하고 사용 가능), 유효성(정확하고 완벽하게 사용자의 목표에 달성), 학습성(누구나 쉽게 배우고 사용 가능), 유연성(사용자의 인터랙션을 최대한 포용하고 실수 방지)  
- 리치 클라이언트(SW 실행을 클라이언트가 책임) vs 씬 클라이언트(SW 실행을 전적으로 서버가 책임)  
- SSO(Single Sign On) : 한 번의 로그인을 통해 다른 시스템에도 자동으로 접속하여 이용하는 방법  
- 사용성 테스트 : 사용자가 직접 제품을 사용하면서 미리 작성된 시나리오에 맞춰 과제를 수행하는 테스트  
- 페르소나 : 잠재적 사용자의 다양한 목적과 관찰된 행동 패턴을 응집시켜놓은 가상의 사용자  
- 요구사항 매트릭스 : 페르소나의 목적을 기준으로 데이터 요구, 기능의 기반으로 만든 요구사항 표  
- 3C 분석(고객/경쟁사/자가 분석), SWOT(강점/약점/기회/위협 분석), 목업(와이어프레임보다 더 실제처럼)  
- 와이어프레임 : 이해관계자들과 화면 구성을 협의하거나 화면 단위로 대략적인 레이아웃만 구성한 문서  
- 스토리보드 : UI 화면설계를 위해 와이어프레임과 DB연동, 정책 등 구축하는 서비스의 정보가 수록된 문서  
- 프로토타입 : 정적 화면으로 설계된 와-프, 스-보에 동적인 요소를 적용하여 만든 시뮬레이션 가능한 모형  

7. 애플리케이션 테스트 관리  
- 살충제 패러독스 : 동일한 TC로 테스트를 진행하면 더 이상 새로운 결함을 찾을 수 없다. 새로운 TC 필요  
- 오류-부재의 궤변 : 사용자의 요구사항이 충족되지 않으면 결함이 없다 해도 품질이 높다고 볼 수 없다.  
- 워크스루 : 검토회의 전 요구사항 명세서를 미리 배포하여 사전 검토 회의를 통해 결함 발견  
- 인스펙션 : 요구사항 명세서 작성자를 제외한 다른 검토 전문가들이 결함 발견  
- 동료 검토 : 요구사항 명세서 작성자가 내용을 직접 설명, 동료들이 이를 들으면서 결함 발견  
- 테스트 커버리지 : 주어진 TC에 의해 수행되는 SW의 테스트 범위를 측정하여 테스트의 정확성과 신뢰성을 향상시키는 역할을 수행하는 테스트 품질 측정 기준  
- 테스트 : 검증/확인, 단위->통합->시스템->인수, 정적/동적, 구조 기반/명세 기반/경험 기반으로 분류 가능  
- 검증 테스트 : 개발자 시각 vs 확인 테스트 : 사용자 시각  
- 단위 테스트 : 사용자 요구사항에 대한 단위 모듈, 서브루틴 등을 테스트 (인터페이스/자료구조/실행경로)  
- 통합 테스트 : 단위 테스트를 통과한 SW/HW 컴포넌트 간 인터페이스 및 연동 기능을 구조적으로 테스트  
- 하향식 통합(깊이 or 너비 우선, Stub), 상향식 통합(Cluster->Driver), 빅뱅 통합(모든 모듈을 한번에 통합)  
- 시스템 테스트 : 실제 환경과 최대한 유사한 환경에서 진행 (단위/통합 테스트 통과 후)  
- 인수 테스트 : 사용자의 입장에서 테스트. 알파 테스트와 베타 테스트 존재  
- 정적 테스트 : 명세서나 소스코드를 대상으로 분석하는 테스트(워크스루, 인스펙션, 코드 검사 등)  
- 동적 테스트 : 프로그램을 실행하여 오류를 찾는 테스트(블랙/화이트 박스 테스트)  
- 구조 기반 테스트(화이트박스 테스트) : 구문 커버리지(모든 명령문을 한번씩), 결정 커버리지(모든 결정문이 참과 거짓 수행), 조건 커버리지(모든 결정문 내 각 조건이 참과 거짓 수행), 조건-결정 커버리지(개별 조건식도 참과 거짓 수행), 다중 조건 커버리지(모든 개별식 조건의 모든 조합 고려)  
- 명세 기반 테스트(블랙박스 테스트) : 동등 분할(그룹핑), 경계깞 분석, 결정 테이블, 유스케이스, 상태 전이  
- 경험 기반 테스트 : 테스터의 경험을 기반으로 수행(에러 추정, 체크리스트, 탐색적 테스팅)  
- 회복(결함->실패 후 올바르게 복구), 안전(침입으로부터 보호), 강도(과부하 시 정상 실행), 구조(논리적 경로, 복잡도), 회귀(변경된 코드에 새로운 결함 여부), 병행(변경/기존 SW에 동일한 데이터 입력 후 비교)  
- 맥케이브 순환복잡도 : 제어 흐름의 정보를 정량적으로 표시하는 기법, 간선 수 - 노드 수 + 2  
- 테스트 하네스 : 테스트를 지원하기 위한 코드와 데이터를 의미, 개발자가 테스트를 위해 작성함  
- 테스트 오라클 : 테스트의 결과값이 참인지 거짓인지 판단하기 위해 사전에 정의한 참 값과 비교  
  참(모든 입력값), 샘플링(몇 개 입력값만), 휴리스틱(나머진 추정), 일관성 검사(변경 전후 비교) 오라클  
- 성능 테스트 도구 : APP 처리량, 응답 시간(작업요청~응답도착), 경과 시간(작업의뢰~처리완료) 테스트  
- 자원 사용률 : APP이 작업을 처리할 동안의 CPU, MEM, DISK 등의 사용량  
- 외계인 코드 : 아주 오래되거나 참고문서 또는 개발자가 없어 유지보수 작업이 매우 어려운 코드  
- 스파게티 코드 : 실행은 되지만 소스 코드가 얽혀 있어 구조를 파악하기 힘든 코드  
