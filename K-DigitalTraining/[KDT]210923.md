Open Stack - 풀링된 가상 리소스를 사용하여 프라이빗 및 퍼블릭 클라우드를 구축하고 관리하는 오픈소스 플랫폼

대시보드를 한눈에 보는것이 클라우드watch의 기본  

[VPC 생성]  
[에지 서브넷 생성]  
[인터넷 게이트웨이 생성, VPC 연결]  
[라우팅 테이블 - 명시적 연결에 에지 서브넷 추가]  
[NACL 생성 - 인바운드 모든 트래픽 허용]  
[보안그룹 생성 - 인바운드 22 허용]  
[EC2 인스턴스 생성 - 보안그룹 지정, 키페어 생성]  
[키페어 생성 - pem 방식 : puttygen에서 ppk로 변환]  
[탄력적 ip 생성, EC2 인스턴스 연결]  
[인스턴스 선택 - 연결 클릭 - ubuntu@xx.xxx.xxx.xxx 형식 복사]  
[putty - session에 ubuntu@형식 붙여넣기]  
[putty - SSH - Auth - 키파일 불러오기]  
[연결, Accept]  
[이하 가상머신 내부 cli 환경]  

`docker --version`  
`sudo apt list | grep docker-ce`  
`ls -al /usr/share/keyrings/`  
`sudo apt install apt-transport-https ca-certificates curl gnupg lsb-release`  
`curl -fsSL http://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg`  
`ls -al /usr/share/keyrings/`  
`echo "deb [arch=amd64 signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/ubuntu/ $(lsb_release -cs) stable" | sudo tee /etc/apt/sources.list.d/docker.list > /dev/null`  
`cat /etc/apt/sources.list.d/docker.list`  
`sudo apt update`  
`sudo apt list | grep docker-ce`  
`sudo apt install docker-ce docker-ce-cli containerd.io`  
! 참고사항 : 버전에 맞추어서 확인 후 설치 
>> sudo apt-cache madison docker-ce docker-ce-cli
>> sudo apt install docker-ce=버전 docker-ce-cli=버전 containerd.io  

`sudo docker version`  
`systemctl status docker`  

잘 안되는 경우 위 [](대괄호) 부분이 준수되었는지 확인.  
CLI환경에서 명령어 입력이 안되는 등의 경우 Crtl + c  

관리자권한이 필요

`sudo usermod -a -G docker $USER`  
`sudo service docker restart`  
sudo를 사용하지 않아도 도커 서비스를 사용하는데 문제가 없음  
`docker search nginx`  
오피셜한 이미지) 도커허브에서 이미지를 가져오기위해  
`docker pull nginx`  
도커허브에서 가져온 이미지 확인  
`docker images`  
docker run -d --name insecweb -p 80:80 이미지의 리포지토리이름:Tag에 있는 이름  
`docker run -d --name insecweb -p 80:80 nginx:latest`   
`docker ps -a`  
웹사이트 80이라는 것을 도커에서 백그라운드로 열었음  
이제 해당 서브넷이 그 영역을 정상적으로 받았는지, 라우팅 테이블이 서브넷과 연결이 되어 인터넷 연결이 되었는지, 인터넷 게이트웨이도 vpc와 연결이 되었는지 확인  
`docker stop`  
docker run -d --name infosecweb -p 443포트 이미지 시작  
`docker run -d --name infosecweb -p 443:443`  

파이썬 버전 확인  
`python3 --version`  

pip3 및 기타 Python 도구 설치  
`sudo apt install build-essential python3-pip libffi-dev python3-dev python3-setuptools libssl-dev`  

 샌드 박스 환경에서 flask를 분리하고 실행할 가상 환경 설치  
`sudo apt install python3-venv`  

flask 디렉터리를 만들고 탐색  
`mkdir flask_dir && cd flask_dir`  

Python을 사용하여 가상 환경 생성  
`python3 -m venv venv`  

플라스크 설치할 수 있도록 활성화  
`source venv/bin/activate`  

 pip를 사용하여 flask 웹 프레임 워크를 설치하면 Jinja2, werkzeug WSG 웹 응용 프로그램 라이브러리 및 해당 모듈을 포함한 flask의 모든 구성 요소가 설치됨  
`pip3 install flask`  

플라스크 버전 확인  
`flask --version`  

`vi app.py`  
```from flask import Flask, make_response, jsonify, request
​
app = Flask(__name__)
​
@app.route('/')
def hello():
return 'Hello World!'
​
if __name__ == '__main__':
app.run(host='0.0.0.0', port=5001)
```  
터미널 세션이 종료되어도 Flask서버 프로그램 실행이 백그라운드에서 유지되도록 함  
`nohup python -u train.py &`  