오늘은 이전에 만들었던 vpc, subnet 전부 삭제하고 스크립트로 생성해볼 예정  

파이썬-람다로 제어명령을 날릴 수 있음  

관리자 명령 프롬프트 - C 드라이브 시스템 경로 또는 파일을 잘못 건드리면 윈도우를 다시 깔아야 하기 때문에 C 드라이브에 temp라는 공간을 만들어놓고 명령어 사용 연습을 하는 것을 추천  

참고 사이트  
https://docs.aws.amazon.com/ko_kr/vpc/latest/userguide/vpc-subnets-commands-example.html  
https://docs.aws.amazon.com/cli/latest/index.html  

`aws configure` //접속  

ID, Key, region name(us-east-2), output format(기본이 json이라 그냥 enter 쳐도됨) 입력  

aws s3 확인해 본 결과 아무것도 없으므로 만들 수 있음  

## aws vpc 생성  
결과는 JSON 파일로 출력  

`aws ec2 create-vpc --cidr-block 10.0.0.0/20`  
{
    "Vpc": {  
        "CidrBlock": "10.0.0.0/20",  
        "DhcpOptionsId": "dopt-09a6f9116df4c52ab",  
        "State": "pending",  
        "VpcId": "vpc-0d162c7ee0fb7050f",  
        "OwnerId": "172362120015",  
        "InstanceTenancy": "default",  
        "Ipv6CidrBlockAssociationSet": [],  
        "CidrBlockAssociationSet": [  
            {  
                "AssociationId": "vpc-cidr-assoc-0798f9a20a34afbfb",  
                "CidrBlock": "10.0.0.0/20",  
                "CidrBlockState": {  
                    "State": "associated"  
                }  
            }  
        ],  
        "IsDefault": false  
    }  
}   
## subnet 생성  
`aws ec2 create-subnet --vpc-id vpc-0d162c7ee0fb7050f --cidr-block 10.0.0.0/24`  
{  
    "Subnet": {  
        "AvailabilityZone": "us-east-2c",  
        "AvailabilityZoneId": "use2-az3",  
        "AvailableIpAddressCount": 251,  
        "CidrBlock": "10.0.0.0/24",  
        "DefaultForAz": false,  
        "MapPublicIpOnLaunch": false,  
        "State": "available",  
        "SubnetId": "subnet-0f8f5b154c9ede83f",  
        "VpcId": "vpc-0d162c7ee0fb7050f",  
        "OwnerId": "172362120015",  
        "AssignIpv6AddressOnCreation": false,  
        "Ipv6CidrBlockAssociationSet": [],  
        "SubnetArn": "arn:aws:ec2:us-east-2:172362120015:subnet/   subnet-0f8f5b154c9ede83f"  
    }  
}    
서브넷을 여러개 만든다고 하면 cidr-block에 ipcidr만 바꿔주면 됨. 후에 반복하는 스크립트를 만들수도 있음  

## 게이트웨이 생성  
`aws ec2 create-internet-gateway`  
{  
    "InternetGateway": {  
        "Attachments": [],  
        "InternetGatewayId": "igw-03cc1c2668a6a2942",  
        "OwnerId": "172362120015",  
        "Tags": []  
    }  
}   
## vpc와 게이트웨이 연결  
`aws ec2 attach-internet-gateway --vpc-id vpc-0d162c7ee0fb7050f --internet-gateway-id igw-03cc1c2668a6a2942`  

## 라우팅 테이블 생성  
기본으로 제공해주는 라우팅 테이블 말고 직접 생성해서 사용할 것임  

`aws ec2 create-route-table --vpc-id vpc-0d162c7ee0fb7050f`  
{  
    "RouteTable": {  
        "Associations": [],  
        "PropagatingVgws": [],  
        "RouteTableId": "rtb-0c5f53b9d484b0259",  
        "Routes": [  
            {  
                "DestinationCidrBlock": "10.0.0.0/20",  
                "GatewayId": "local",  
                "Origin": "CreateRouteTable",  
                "State": "active"  
            }  
        ],  
        "Tags": [],  
        "VpcId": "vpc-0d162c7ee0fb7050f",  
        "OwnerId": "172362120015"  
    }  
}    

## 라우팅 테이블에 인터넷 게이트웨이 연결
`aws ec2 create-route --route-table-id rtb-0c5f53b9d484b0259 --destination-cidr-block 0.0.0.0/0 --gateway-id igw-03cc1c2668a6a2942`  
주의 : CLI 명령어 버전을 확인해야 함. 버전 1은 적용이 안됨. 버전 2 사용  

## NACL 생성  
`aws ec2 create-network-acl --vpc-id vpc-0d162c7ee0fb7050f`  

## 보안그룹 생성  
aws ec2 create-security-group --group-name 보안그룹이름 --description "보안그룹 설명"  

`aws ec2 create-security-group --group-name game-private-sg --description "game-private-sg" --vpc-id vpc-09f335973c1ae142c`  
--------------------------------------------------------------------------
NACL, 보안그룹 포트 우선 전부 열어준 뒤 AMI-UI (Docker 이미지) Public 서브넷 생성  
EIP 생성 후 연결  
ECR = Elastic Container Service 메뉴에서 리포지토리 생성  

## Elastic Container Registry  
이전에 도커 만들어놓은 상태로 AMI 이미지 만들었던걸 다시 EC2로 만들어서 이미지 존재함  
`sudo apt update`  
`sudo apt install awscli`  
`aws --version`  
`aws configure`  
ID, Access Key, region name 입력(C:\users\user\.aws\credentials 파일에 키값 정보 복붙)  
도커에 로그인할 정보를 가져옴  
` aws ecr get-login --no-include-email --region us-east-2`  
정보 docker login부터 정보 복사해서 붙여넣기하면 login succeeded.  
```docker login -u AWS -p eyJwYXlsb2FkIjoiajlZc2YzQW5iUGNGWWhjbVJIMlZtTEJuMUYrajR0QWFldm5JMXJEVWRnMlZWeWNsZjZvTEUyZEtvU3I3eVNKV0w5UFpUMTdOTnBKbFZFNGJ1SER6M3lBb0c5TXVZakpSQXJmeHc5dGhXNE1MS2pqRGM1M2JZSGw2YTRmNUVjVW1jN25tSGJEV3VHOThHREZsdXU1Y093ZW1iWkxhL09SVUhjVEgvRjNnQ0hXOHlRWFczQmQ3MUxERGRTLzRDMUxLYWp2Z3ZOOENPSzNGNDQrdDE1dlJicEgxOThHUTY0aVhVUHM1TG5JMDFEZjgxVVBUMTNybGhLWmhPZXBaMnZ6RmlIWjdDUnFXZzY1WEUvdGNZVlNpZUlzaGZSWCtZakRXcGh3ekJqcHlacDdGVzBqY0RUb2FYbWJxN2hObXdTUnFReW1wNm9KN1Ztb0hzV05ZVVNTbUYxUDVON0N1K3g4UGFVaUc3QjFZUnl6REtmVERBZ1Jqd25pUUpTZ09BNEw0SEJhV3JVeGIwRnlLcWxUVjFuT2lDZmpYUE1UNTRRNVNYNVQ5dE9kZnRLZFBMTkMxTFRFMHpPTWsydi9xVnhFSURvODF2a3JDRzhNYWdyd3FGQXNwQTFPdDBOUEpHYXV3TjJNQ3loQVBHVHUvSWJ1QndCc3ZOMFRlaUNmM3BHdUhncTYwTlNlVXNMZnRqb2VwbjdOQkpoRGswc0RBRXViZ0czTmpqNmMvc0pjQTNMRzBzU1B2TVJoTUdrdUFaOWVWaHNVNm56ZUdKM3AvRVNXREhXc3FSRzJmNTNralFOajdmVS9lR044RnlQVlBFUngzdWpiT1lsS2NwSHI0LzlYK2Q3NnE4SHZKcVE5czRzdDRtRTRBY2dHRnpCejA5aEVxbFJrWmZTcWttTnNjU2RnYTcrdEVmWEJhdlFUR0s5UUp1enVuY2tTbFN4QmdUWUV6ZElRcElWMHk2Vk1WeFRrWS9Qazl5cG9HZWZ6WDNwdWhYWDVLbmcxUGF0NmR1VkxDQkQ4VkE2VGtWYjVvTG1Hd0JndFN0aUUzOFVYU0hmQzBuMEVHcFdQa3pObmdRVTFFeUIrWmZKa0F1elA4aGNmTlRnOHBYcGJaME0ralJsMzh3eEFYZlNJMHlIb1lSNDVOMHk0OTNNVTQ2VW4rRC9SREVtY0d2aWg5cnNmcWNXZDZoaFVQMm5hbGhvdTJzamF5bURralMvRFdZWVJDdG1KcGtYdURUSUpmaWNsQmJSUW9IVVd0eWJHM1hZdzlqSUlsMlZOdzRxNndJb1lDcGxsYXhFemU3VFJFVXlkaGpvL2lLVGtQREIxQmg1OFR1aGRJYUlGbXA0N3F3QjJPQWkxL0dXdDBXRTZDcUN2akY0RllIRDVPWVdjTjc1VXlaR3ZPT3c9PSIsImRhdGFrZXkiOiJBUUVCQUhqQjcvaWd3TWc0TlB3YXVyeFNJWXg0SGZueHVHYy80OGJEd3Z3RHBOWVdaZ0FBQUg0d2ZBWUpLb1pJaHZjTkFRY0dvRzh3YlFJQkFEQm9CZ2txaGtpRzl3MEJCd0V3SGdZSllJWklBV1VEQkFFdU1CRUVETUlIUDNHT1B2ckxrWG1TeXdJQkVJQTdpWTI4eEtLQitmMHJqcmZDbFgzQkErcjZmdDZQaEdDYldYS3pCQzlsL3VXT1hjN1B2T3ZoNlZNeCtHQms1c1ZkSHREYVlHWE9XakdlTWhBPSIsInZlcnNpb24iOiIyIiwidHlwZSI6IkRBVEFfS0VZIiwiZXhwaXJhdGlvbiI6MTYzNDIzMDczMX0= https://172362120015.dkr.ecr.us-east-2.amazonaws.com```  
주소는 프라이빗 리포지토리주소  
docker tag nginx:latest 도커이미지리스트의 이름:태그값  
`docker tag nginx:latest 172362120015.dkr.ecr.us-east-2.amazonaws.com/cysunecr:latest`  
docker push 경로:태그값
`docker push 172362120015.dkr.ecr.us-east-2.amazonaws.com/cysunecr:latest`  

## ECS  
ECS 생성 - 클러스터 생성 후 NLB 생성 후 작업 정의함. 작업 정의 - 클러스터에서 작업 서비스 시작  
클러스터 생성 - EC2 Linux+네트워킹 -클러스터 이름/온디맨드/ EC2 인스턴스 유형 t2.micro / 기존키페어/vpc,subnet(UI),보안그룹(Public)설정  
작업정의 - 새 작업 정의 생성  

시작유형 호환성 - EC2  

태스크 정의 이름 - game-ui-ecs-task  

태스크 역할 - 없음  

네트워크 모드 - 브리지  

작업크기 작업 메모리 - 1GB , 작업 cpu - 1vCPU  

컨테이너 정의 - 컨테이너 추가

>컨테이너 이름 -game-ui-service  

>이미지(경로 - ecr에 있는 프라이빗 레포지토리 경로(URI)) 이미지 넣고 내가 만든 태그까지 확인(cysunecr:latest) 

> 포트매핑 - 호스트포트 8081 / 컨테이너포트 80 / tcp 

> 나머지 다 스킵 후 추가  

생성한 클러스터 클릭 후 생성  
만약 이미지를 못가져오면 오류생김. 이 활동이 끝나면 클러스터-목록으로 가보면 내가 만든 클러스터가 있을 것 - 생성    
시작유형-EC2  
클러스터의 서비스 이름 : game-ui-service  
서비스 유형 : REPLICA(복제)  
배포유형 - 롤링 업데이트 배치템플릿-AZ균형분산  
로드밸런싱 : 로드밸런서 유형 없음. (네트워크 로드밸런서를 미리만들어놓으면 편할듯)  
nlb 바로 만들어줌 ui-nlb 8081듣는 것으로 생성 후 로드밸런싱할 컨테이너/컨테이너 이름:포트에 로드밸런서 추가해줌  
>프로덕션리스너포트 8081:TCP  
>대상그룹이름 game-ui-tg  
route53을 사용한다면 서비스검색(선택사항) 체크. 일단은 체크안함  
Auto Scaling(선택사항)  
최소 1, 최대 2  
자동작업조정 정책 - 대상추적 /ECSpolicy , 대상값 50    
생성 - 로드밸런싱-대상그룹-타겟 넣어서 헬스체크 함  
체크 끝난 후 healthy 뜨면 ecs에서 뒤로가기 해서 다시 확인 후 서비스 생성   

Q. 라우팅 테이블 왜 두개인가?   

A. IGW를 등록해둔 라우팅 테이블은 퍼블릭 서브넷을 명시적으로 지정해주어야 함  
NAT를 등록해둔 라우팅 테이블은 외출할 프라이빗 서브넷들을 명시적으로 지정해주어야 함  
명시적으로 지정할 서브넷이 서로 다르기 때문에 두 가지의 라우팅 테이블이 필요함  
각 프라이빗 서브넷은 사설IP를 가지고 NAT를 방문해서 외출증(공인IP)을 받고 나가게 됨  